聚合函数
===================

聚合函数对一组值进行操作以计算单个结果。

除`count`、`count_if`、`max_by`、`min_by`、`approx_distinct`外，所有聚合函数均忽略空值，当没有输入行或所有值都为null时，均返回null。例如：`sum`
返回null而不是零，`avg`在计数中不包括null值。‘coalesce’功能可以
用于将null转换成零。

某些聚集函数（如`array_agg`）根据输入的顺序产生不同的结果
值。可以通过在聚合函数中编写一个`order-by-clause`来指定这种排序：

array_agg（x ORDER BY y DESC，按照排序方式排序）
array_agg（x排序方式x,y,z）

通用聚合函数
---------------------------


**任意(x)** -\> \【与输入相同\】

返回`x`的任意非空值（如果存在）。



**array\_agg(x** -\>数组\<\【与输入相同】\>

返回一个从输入`x`元素创建的数组。



**avg(x)** -\>双精度浮点数

返回所有输入值的平均值（算术平均数）。



**avg（时间间隔类型）** -\>时间间隔类型

返回所有输入值的平均间隔长度。



**布尔\_and（布尔型）** -\>布尔型

如果所有输入值都为`TRUE`，则返回`TRUE`，否则返回`FALSE`。



**布尔\_or（布尔型）** -\>布尔型

如果输入值中有任何一个为`TRUE`，则返回`TRUE`，否则返回`FALSE`。



**checksum(x)** -\> varbinary

返回给定值的顺序不敏感的校验和。



**count(\*)** -\>大于

返回输入行数。


**count(x)** -\>大于

返回非空输入值的数量。



count\_if(x)** -\>大于

返回`TRUE`输入值的个数。此函数等价于`count(CASE WHEN xTHEN 1 END)`。



**every（布尔型）** -\>布尔型

这是`bool_and`{.interpreted-text role="func"}的别名。



**几何\_mean(x)** -\>双精度

返回所有输入值的几何平均值。



**max\_by(x, y)** -\> \【与x相同】

返回所有输入值中与`y`最大值相关的`x`的值。



**max\_by(x, y, n)** -\>数组\<\【与x相同】\>

返回与所有输入值中最大的一个关联的`x`的`n`值，按`y`降序排列。



**min\_by(x, y)** -\> \【与x相同】

返回所有输入值中与`y`的最小值相关的`x`的值。



**min\_by(x, y, n)** -\>数组\<\【与x相同】\>

返回与所有输入值中最小的`n`相关的`x`的`n`值，按`y`升序排列。



**max(x)** -\> \【与输入相同\】

返回所有输入值的最大值。



**max(x, n)** -\>数组\<\【与x相同】\>

返回`x`所有输入值中最大的`n`值。



**min(x)** -\> \【与输入相同\】

返回所有输入值的最小值。



**min(x, n)** -\>数组\<\【与x相同】\>

返回`x`所有输入值的`n`最小值。



**sum(x)** -\> \【与输入相同】

返回所有输入值的总和。



按位聚合函数
---------------------------



**按位排序\_and\_agg(x)** -\> bigint

返回2补码表示法中所有输入值的按位与。



**按位\_or\_agg(x)** -\>大号

返回2补码表示法中所有输入值的按位或。

地图聚合函数
-----------------------

**直方图(x)** -\>地图(K,bigint)

返回一个映射，其中包含每个输入值出现的次数计数。



**map\_agg(key, value)** -\>映射（K,V） ，表示对KV进行映射。

返回一个从`key` / `value`对中创建的映射。



**map\_union(x(K,V))** -\>映射（K,V）映射方式

返回所有输入映射的并集。如果在多个输入映射中找到一个键，则所得到的映射中的键值来自任意输入映射。



**multimap\_agg(key, value)** -\> map(K,array(V))

返回一个从输入`key` / `value`对创建的multimap。每个键可以关联多个值。



近似聚合函数
-------------------------------



**approx\_distinct(x)** -\>对比度分析工具

返回非重复输入值的近似数目。该函数提供`count(DISTINCT x)`的近似值。如果所有输入值都为空，则返回零。

这个函数应该产生2.3%的标准误差，它是所有可能集合上的误差分布（近似正态）的标准差。它不保证任何特定输入集的错误上限。



**近似值\_可区分度(x, e)** -\> bigint

返回非重复输入值的近似数目。该函数提供`count(DISTINCT x)`的近似值。如果所有输入值都为空，则返回零。

该函数产生的标准误差不应大于`e`，它是所有可能集合上的误差分布（近似正态）的标准差。它不保证任何特定输入集的错误上限。当前实现要求`e`在`[0.0040625, 0.26000]`范围内。



**近似值\_百分比（x，百分比）** -\> \【同x\】

返回给定`百分比'下`x`所有输入值的近似百分位数。`percentage`的值必须在0和1之间，并且对于所有输入行必须是常量。



**近似值\_percentile（x，百分比）** -\>数组\<\【与x相同】\>

返回`x`的所有输入值在每个指定百分比的近似百分位。‘百分比’数组的每个元素必须在零和一之间，并且数组必须为常量
输入行数。



**近似值\_百分比（x,w，百分比）** -\> \【与x相同】

返回所有输入值`x`的近似加权百分位数，使用每项目权重`w`在百分比`p`。权重必须为至少一个的整数值。它实际上是百分数集中值`x`的复制计数。`p`的值必须在0和1之间，并且对于所有输入行必须是常量。



**近似\_百分位（x,w，百分比，准确度）** -\> \【同x\】

返回所有输入值`x`的近似加权百分位，使用每项目权重`w`按百分比`p`计算，最大秩误差`accuracy`。权重值必须为整数，至少为
一个。它实际上是百分数集中值`x`的复制计数。`p`的值必须在0和1之间，并且对于所有输入行必须是常量。`accuracy`必须是一个大于
零且小于一，并且对于所有输入行，它必须是常数。



**近似值\_percentile（x, w，百分比）** -\>数组\<\【与x相同】\>

在数组中指定的每个给定百分比处，使用每个项的权重`w`，返回所有输入值`x`的近似加权百分数。权重必须为至少一个的整数值。是
实际上是百分位数集合中值`x`的复制计数。数组的每个元素必须介于0和1之间，并且对于所有输入行，数组必须是常量。



**approx\_set(x)** -\>日志收集工具

请参考`hyperloglog`{.interpreted-text角色="doc"}中的说明。



**merge(x)** -\> HyperLogLog

请参考`hyperloglog`{.interpreted-text角色="doc"}中的说明。



**merge(qdigest(T))** -\> qdigest(T)合并后的数据格式

请参考`qdigest`{.interpreted-text角色="doc"}中的说明。



**qdigest\_agg(x)** -\> qdigest\<\【与x相同\】\>（与x相同）

请参考`qdigest`{.interpreted-text角色="doc"}中的说明。



**qdigest\_agg(x, w)** -\> qdigest\<\【与x相同\】\>（与x相同\）

请参考`qdigest`{.interpreted-text角色="doc"}中的说明。



**qdigest\_agg(x, w, accuracy)** -\> qdigest\<\【与x相同\】\>（与x相同\）

请参考`qdigest`{.interpreted-text角色="doc"}中的说明。



**数值型\_直方图（桶、值、权重）** -\>映射\<double,double\>

计算一个近似直方图，其中所有`值`的`桶`最多`桶'数目，每个项目的权重为`权重`。该算法主要基于以下因素：

"```{.none}"
Yael Ben-Haim和Elad Tom-Tov,"一种流式并行决策树算法"，
J.机器学习研究11 (2010) ,pp. 849--872.
```

`桶`必须是`bigint`。`value`和`weight`必须是数字。



**数字\_直方图（桶，值）** -\>映射\<double,double\>

计算一个近似直方图，其中所有`值'的桶数最多为`buckets`。该函数相当于`numeric_histogram`的变体，其权重为``，每个item的权重为`1`。


统计汇总函数
-------------------------------


**corr(y, x)** -\>双精度

返回输入值的相关系数。



**covar\_pop(y, x)** -\>双精度浮点数

返回输入值的总体协方差。



**covar\_samp(y, x)** -\>双精度浮点数

返回输入值的样本协方差。



**峭度(x)** -\>双峰

返回所有输入值的多余峰度。使用下列表达式的无偏估计：

"```{.none}"
峭度(x)=n(n+1)/(n-1)(n-2)(n-3))和[(x_i-mean)^4]/stddev(x)^4-3(n-1)^2/((n-2)(n-3))
```




**regr\_intercept(y, x)**-\>双精度浮点数

返回输入值的线性回归截距。`y`为依赖值。其中，`x`为独立值。



**regr\_slope(y, x)** -\>倍率，表示从左到右的双倍率。

返回输入值的线性回归斜率。`y`为依赖值。其中，`x`为独立值。



**偏斜度(x)** -\>加倍

返回所有输入值的偏斜度。



**stddev(x)** -\>双精度浮点数

这是`stddev_samp`{.interpreted-text role="func"}的别名，此处仅为示例，请以实际环境为准。



**stddev\_pop(x)**-\>双精度浮点数

返回所有输入值的总体标准偏差。



**stddev\_samp(x)** -\>双精度浮点数

返回所有输入值的样本标准差。



**方差(x)**-\>倍

这是`var_samp`{.interpreted-text role="func"}的别名，用于区别不同的角色。



**var\_pop(x)**-\>加倍显示

返回所有输入值的总体方差。



**var\_samp(x)**-\>双精度浮点数

返回所有输入值的样本方差。


Lambda聚合函数
--------------------------

**reduce\_agg（输入值T，初始状态S，输入函数(S,T,S），合并函数(S,S,S))** -\> S

将所有输入值缩减为单个值。对于每一个非空输入值，都会调用`inputFunction`。`inputFunction`除了取输入值外，还取当前状态，初始为`initialState`，并返回新的状态。调用`combineFunction`将两个状态组合成一个新的状态。返回最终状态：

SELECT id,reduce_agg（数值，0,(a,b）)->a+b,(a,b)->a+b) ，依次类推
从(
价值
（1, 3），
（1, 4），
（1, 5），
（2, 6），
(2, 7)
)AS t（id，值）
GROUP BY id方式；
-- (1, 12)
-- (2, 13)
    
SELECT id,reduce_agg（值，1,(a,b）->a * b,(a,b)->a * b) ，依次类推。
从(
价值
（1, 3），
（1, 4），
（1, 5），
（2, 6），
(2, 7)
)AS t（id，值）
GROUP BY id方式；
-- (1, 60)
-- (2, 42)

状态类型必须是布尔型、整型、浮点型或日期/时间/间隔型。
