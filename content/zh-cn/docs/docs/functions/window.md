窗口函数
================

窗口函数在查询结果的行之间执行计算。它们在HAVING子句之后，ORDER BY子句之前运行。调用窗口函数需要使用`OVER`特殊语法
子句指定窗口。窗口由三个部分组成：

-分区规范，它将输入行分隔为不同的分区。这类似于`GROUP BY`子句如何将行分成不同的组以用于聚合函数。
+排序规范，它确定窗口函数处理输入行的顺序。
+窗口框架，为给定的行指定要由函数处理的行的滑动窗口。如果没有指定帧，则默认为`未绑定预取范围`，与`未绑定预取范围和当前行范围`相同。此帧包含从分区开始到当前行的最后一个对等点的所有行。

例如，以下查询按价格对每个文员的订单进行排序：

选单键，店员，总价
（按职员划分）
（按总价排序）
从订单
订单文员，兰克

聚合函数
-------------------

通过添加`OVER`子句，所有`aggregate`都可以用作窗口函数。聚合函数为
计算当前行窗口框架中的每行。

例如，下面的查询为每个文员生成按天滚动的订单价格总和：

订单选择文员，订单日期，订单键值，总价
金额（总价）OVER(营业员分区
ORDER BY orderdate) AS滚动汇总数据
从订单
按文员顺序，按日期顺序，按关键字顺序

排行榜功能
-----------------

**cume\_dist()** -\>比格因特

返回一组值中某个值的累积分布。结果是窗口分区中与窗口排序中的行前面的行数或对等的行数除以窗口分区中的总行数。因此，排序中的任何关联值都将计算为相同的分布值。

**密级\_rank()** -\>大号

返回一个值在一组值中的排序。这与`rank`类似，只是tie值在序列中不产生间隙。

**ntile(n)** -\>比格因特

将每个窗口分区的行分成n个桶，从1到最多n。桶的值最多相差1。如果分区中的行数没有平均分为
然后，从第一个桶开始，为每个桶分配一个剩余值。

例如，对于`6`行和`4`个桶，桶的值将如下：`1``1``2``2```3````

**百分比\_rank()** -\>双倍

返回一个值在一组值中的百分比排名。结果为`(r-1)/(n-1)`，其中`r`为该行的`rank`,`n`为该window分区的总行数。

**rank() -\>比根特**

返回一个值在一组值中的排序。秩是行之前与行不对等的行数加一。

因此，排序中的绑定值将在序列中产生间隙。对每个窗口分区进行排序。

**row\_number()** -\>宏定义

根据窗口分区内行的顺序，返回每行的唯一顺序号，从1开始。


价值函数
---------------

**first\_value(x)** -\> \【与输入相同】

返回窗口的第一个值。


**last\_value(x)** -\> \【与输入相同\】

返回窗口的最后一个值。


**nth\_value（x，偏移量）** -\> \【同输入\】

返回从窗口开始到指定偏移量处的值。
偏移从`1`开始。offset可以是任意标量表达式。如果偏移量为null或大于窗口中的值的数量，则返回null。偏移量为零或负数的错误。

**lead（x\[，偏移量\[, default\_value\]\]）** -\> \【与输入相同\】

返回窗口当前行后的`offset`行的值。偏移量从当前行`0`开始。offset可以是任意标量表达式。默认值为`1`。如果offset为空或者
大于窗口，则返回`default_value`，如果没有指定返回`null`。



**lag（x\[，偏移量\[, default\_value\]\]）** -\> \【与输入相同\】

返回窗口Offsets从`0`开始的当前行之前的`offset`行的值。offset可以是任意标量表达式。默认值为`1`。如果offset为空或者
大于窗口，则返回`default_value`，如果没有指定返回`null`。

